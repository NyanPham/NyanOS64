#include "idt.h"
#include "gdt.h"

/*
Exceptions are generated by the CPU (synchronous),
while IRQs are generated by external devices via PIC.

So we'll have the first 32 as CPU exceptions, 
the next 16 are remapped hardware IRQs.
*/

// External references to the IRQ stubs in irq.asm
extern void irq0_stub(void);
extern void irq1_stub(void);
extern void irq2_stub(void);
extern void irq3_stub(void);
extern void irq4_stub(void);
extern void irq5_stub(void);
extern void irq6_stub(void);
extern void irq7_stub(void);
extern void irq8_stub(void);
extern void irq9_stub(void);
extern void irq10_stub(void);
extern void irq11_stub(void);
extern void irq12_stub(void);
extern void irq13_stub(void);
extern void irq14_stub(void);
extern void irq15_stub(void);

// The Interrupt Descriptor Table (IDT).
// This is an array of 256 IDT entries, each corresponding to an interrupt vector.
__attribute((aligned(0x10)))
static idt_entry_t idt[256];

// The IDT Register (IDTR).
// This structure is loaded into the CPU to tell it where the IDT is.
static idtr_t idtr;

// A simple exception handler that halts the CPU.
// This is used for all exceptions by default.
void exception_handler()
{
    __asm__ volatile ("cli; hlt");
}

// Sets a descriptor in the IDT.
void idt_set_descriptor(uint8_t vector, void* isr, uint8_t flags)
{
    idt_entry_t* descriptor = &idt[vector];

    descriptor->isr_low = (uint64_t)isr & 0xFFFF;
    descriptor->kernel_cs = GDT_OFFSET_KERNEL_CODE;
    descriptor->ist = 0;
    descriptor->attributes = flags;
    descriptor->isr_mid = ((uint64_t)isr >> 16) & 0xFFFF;
    descriptor->isr_high = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
    descriptor->reserved = 0;
}

// A boolean array to keep track of which interrupt vectors are in use.
static bool vectors[IDT_MAX_DESCRIPTORS];

// An array of pointers to the ISR stubs in idt.asm.
extern void* isr_stub_table[];

void idt_init()
{   
    // Set up the IDTR.
    idtr.base = (uintptr_t)&idt[0];
    idtr.limit = (uint16_t)sizeof(idt_entry_t) * IDT_MAX_DESCRIPTORS - 1;

    // Set up the default exception handlers.
    for (uint8_t vector = 0; vector < 32; vector++)
    {
        idt_set_descriptor(vector, isr_stub_table[vector], 0x8E);
        vectors[vector] = true;
    }
    
    // Set up the IRQ handlers.
    idt_set_descriptor(32, irq0_stub, 0x8E);
    idt_set_descriptor(33, irq1_stub, 0x8E);
    idt_set_descriptor(34, irq2_stub, 0x8E);
    idt_set_descriptor(35, irq3_stub, 0x8E);
    idt_set_descriptor(36, irq4_stub, 0x8E);
    idt_set_descriptor(37, irq5_stub, 0x8E);
    idt_set_descriptor(38, irq6_stub, 0x8E);
    idt_set_descriptor(39, irq7_stub, 0x8E);
    idt_set_descriptor(40, irq8_stub, 0x8E);
    idt_set_descriptor(41, irq9_stub, 0x8E);
    idt_set_descriptor(42, irq10_stub, 0x8E);
    idt_set_descriptor(43, irq11_stub, 0x8E);
    idt_set_descriptor(44, irq12_stub, 0x8E);
    idt_set_descriptor(45, irq13_stub, 0x8E);
    idt_set_descriptor(46, irq14_stub, 0x8E);
    idt_set_descriptor(47, irq15_stub, 0x8E);


    // Load the IDT.
    __asm__ volatile ("lidt %0" : : "m"(idtr));
    // Enable interrupts.
    __asm__ volatile ("sti");
}
